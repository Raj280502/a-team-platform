from app.core.state import ProjectState
from app.core.llm import get_llm
from app.utils.file_ops import normalize_code
import json
import re


def coder_file_node(state: ProjectState) -> ProjectState:
    """
    Generates code files based on project_scope and architecture.
    Uses a hybrid approach:
    - LLM generates the backend routes/logic
    - Templates handle boilerplate (package.json, vite.config, etc.)
    - App.jsx is generated by LLM with explicit backend routes passed in
    """
    llm = get_llm(role="coder")

    project_scope = state.get("project_scope", {})
    architecture = state.get("architecture", {})
    file_plan = state.get("file_plan", [])
    
    generated = {}
    
    # ==== STEP 1: Generate backend/app.py ====
    project_goal = project_scope.get('project_goal', 'A web application')
    features = project_scope.get('core_features', [])
    
    backend_prompt = f"""You are a Python Flask developer. Generate a complete backend/app.py file.

PROJECT: {project_goal}
FEATURES: {json.dumps(features)}

STRICT REQUIREMENTS:
1. Use Flask with flask_cors
2. Add CORS(app) after app = Flask(__name__)
3. Create routes for EACH feature (use simple paths like /add, /calculate, /tasks - NOT /api/...)
4. Each route should use POST method, accept JSON via request.get_json(), return jsonify()
5. Use in-memory storage (a Python list or dict at top of file)
6. Run with: app.run(host='0.0.0.0', port=5000, debug=False, use_reloader=False)

OUTPUT FORMAT:
- Output ONLY the Python code
- NO markdown code fences
- NO explanations
- Start directly with 'from flask import'

Generate the complete backend/app.py:"""

    response = llm.invoke(backend_prompt)
    backend_code = normalize_code(response.content)
    
    # Validate and fix common issues in backend
    backend_code = fix_backend_code(backend_code)
    generated["backend/app.py"] = backend_code
    
    # Extract routes from backend for frontend
    routes = extract_routes(backend_code)
    print(f"[DEBUG] Extracted routes: {routes}")
    
    # ==== STEP 2: Generate static files (templates) ====
    
    # package.json - always the same
    generated["frontend/package.json"] = """{
  "name": "frontend",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "axios": "^1.6.0"
  },
  "devDependencies": {
    "vite": "^5.0.0",
    "@vitejs/plugin-react": "^4.2.0"
  }
}"""

    # index.html
    title = project_goal[:50]
    generated["frontend/index.html"] = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
</head>
<body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
</body>
</html>"""

    # vite.config.js
    generated["frontend/vite.config.js"] = """import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    host: '0.0.0.0',
    port: 5173
  }
});"""

    # main.jsx
    generated["frontend/src/main.jsx"] = """import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);"""

    # ==== STEP 3: Generate App.jsx with explicit backend routes ====
    routes_str = ", ".join(routes) if routes else "/example"
    
    app_prompt = f"""You are a React developer. Generate a complete App.jsx file.

PROJECT: {project_goal}
FEATURES: {json.dumps(features)}

BACKEND ROUTES AVAILABLE: {routes_str}
BACKEND URL: http://localhost:5000

CRITICAL - Use these EXACT routes:
{chr(10).join(f'- axios.post("http://localhost:5000{r}", data)' for r in routes)}

STRICT REQUIREMENTS:
1. Import React, useState from 'react'
2. Import axios from 'axios'
3. Create a functional component called App
4. Use useState for form inputs and results
5. Call backend using axios.post("http://localhost:5000/ROUTE", data)
6. ROUTES MUST MATCH: {routes_str}
7. Display results in the UI
8. Export default App

OUTPUT FORMAT:
- Output ONLY the JSX code
- NO markdown code fences
- NO explanations
- Start directly with 'import React'

Generate App.jsx:"""

    response = llm.invoke(app_prompt)
    app_jsx = normalize_code(response.content)
    
    # Validate App.jsx has correct imports
    app_jsx = fix_app_jsx(app_jsx, routes)
    generated["frontend/src/App.jsx"] = app_jsx
    
    print(f"[DEBUG] Generated {len(generated)} files")
    return {"files": generated}


def fix_backend_code(code: str) -> str:
    """Fix common issues in LLM-generated backend code."""
    lines = code.split('\n')
    
    # Ensure flask_cors import exists
    has_cors_import = any('flask_cors' in line for line in lines)
    has_cors_call = any('CORS(app)' in line for line in lines)
    
    if not has_cors_import:
        # Add import after flask import
        new_lines = []
        for line in lines:
            new_lines.append(line)
            if line.startswith('from flask import') or line.startswith('import flask'):
                new_lines.append('from flask_cors import CORS')
        lines = new_lines
    
    if not has_cors_call:
        # Add CORS(app) after app = Flask
        new_lines = []
        for line in lines:
            new_lines.append(line)
            if 'app = Flask(' in line:
                new_lines.append('CORS(app)')
        lines = new_lines
    
    # Ensure app.run exists at end
    code = '\n'.join(lines)
    if 'app.run(' not in code:
        code += "\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=False, use_reloader=False)"
    
    return code


def fix_app_jsx(code: str, routes: list) -> str:
    """Fix common issues in LLM-generated App.jsx."""
    # Ensure React import
    if 'import React' not in code:
        code = "import React, { useState } from 'react';\n" + code
    
    # Ensure axios import  
    if 'import axios' not in code:
        code = "import axios from 'axios';\n" + code
    
    # Ensure export default
    if 'export default' not in code:
        code += '\n\nexport default App;'
    
    return code


def extract_routes(code: str) -> list:
    """Extract Flask routes from backend code."""
    routes = []
    for line in code.split('\n'):
        if "@app.route" in line:
            match = re.search(r"['\"](/[^'\"]*)['\"]", line)
            if match:
                route = match.group(1)
                routes.append(route)
    return routes
